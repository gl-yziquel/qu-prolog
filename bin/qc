#! /bin/sh
#
# Copyright (C) 1990 Department of Computer Science, University of Queensland
#
# qc:	Qu-Prolog compiler (a la cc and nc)
#

compileroptions='Z'
compileoptions='GD:ER:Sco:vX'
sizeoptions='d:p:s:u:a:B:O:I:n:i:C:e:h:T:H:'
ipc_options='L'
options=$compileoptions$sizeoptions$ipc_options
file="file.q[ligso]"
usage="usage: $0 [ $options ] $file ... [-- options for Qu-Prolog programs]"

# Compiler Control Options:
#	-Z	run the boot version of the compiler (unavailable in release)
#	-D	define macros
#	-E	only run preprocessor
#	-G	only run term expander
#	-R F	supply term expansion rules
#	-S	stop after compilation
#	-c	do not link objects
#	-o F	generate an executable or object file called F (default a.out)
#	-v	verbose
# Set Data Area Size in qc1:
#	-B N	set binding trail 
#	-O N	set other trail 
#	-C N	set choice stack
#	-e N	set environment stack
#	-H N	set scratchpad
#	-h N	set heap
#	-H N	set scratchpad
#	-n N	set name table
#	-i N	set IP table
# Set Data Area Size in qc1 and in the executable being generated:
#	-s N	set string table
# Set Data Area Size in the executable being generated:
#	-d N	set code area
#	-p N	set predicate table
#	-a N	set atom table
#
# BUGS: If -o is specified with -c, then if there is more than one
#	.ql file, then the object code for all .ql files will be
#	written to the same output file.

#
# location of Qu-Prolog project
#
PATH=/home/pjr/qp_dev/rel/qp8.7/bin:$PATH

#
# names of Qu-Prolog binaries
#
preprocess=/home/pjr/qp_dev/rel/qp8.7/bin/qppp
expand=/home/pjr/qp_dev/rel/qp8.7/bin/qg
compile=/home/pjr/qp_dev/rel/qp8.7/bin/qc1
compversion=qup
assemble=/home/pjr/qp_dev/rel/qp8.7/bin/qa
link=/home/pjr/qp_dev/rel/qp8.7/bin/ql
execute=/home/pjr/qp_dev/rel/qp8.7/bin/qem

#
# Use the line below when dynamic search for libraries is implemented.
#
# libqofiles=""
libqofiles="/home/pjr/qp_dev/rel/qp8.7/prolog/compiler/*.qo /home/pjr/qp_dev/rel/qp8.7/prolog/library/*.qo"

qlfiles=""
qlefiles=""
qifiles=""
qgfiles=""
qgefiles=""
qsfiles=""
qofiles=""

newqifiles=""
newqgfiles=""
newqgefiles=""
newqsfiles=""
newqofiles=""

eflag=false		# flag to stop after making .qi files
gflag=false		# flag to stop after making .qge files
sflag=false		# flag to stop after making .qs files
cflag=false		# flag to stop after making .qo files
vflag=false		# flag to verbose
lflag=			# flag for no IPC services

dflag=			# flag for debugging

Goptions=""		# grammars translator options
Poptions=""		# preprocessor options
Coptions=""		# compiler options
Aoptions=""		# assembler options
Loptions=""		# linker options
Eoptions=""		# emulator options

execfile=a.out		# default executable file name

#
# echo messages
#
verbose()
{
	if [ $vflag = true ]
	then
		echo $*
	fi
}

#
# scan args, looking for options
#
verbose "process command's arguments"

while getopts $compileroptions$options arg
do
	case "$arg" in
	Z)	compversion=boot ;;
	E)	eflag=true ;;
	G)	gflag=true ;;
	S)	sflag=true ;;
	c)	cflag=true ;;
	v)	vflag=true ;;
	o)	execfile="$OPTARG"
		case "$execfile" in
		"")	echo "$0: null output file name" >&2
			exit 1
			;;
		*.q[gls])
			echo "$0: dangerous output file name: $execfile" >&2
			exit 1
			;;
		*.q[gl]e)
			echo "$0: dangerous output file name: $execfile" >&2
			exit 1
			;;
		esac
		;;
	D)
		Poptions="$Poptions -$arg$OPTARG"
		;;
	R)
		Goptions="$Goptions -$arg $OPTARG"
		;;
	[dpa])
		Loptions="$Loptions -$arg $OPTARG"
		Eoptions="$Eoptions -$arg $OPTARG"
		;;
	[su])
		Coptions="$Coptions -$arg $OPTARG"
		Loptions="$Loptions -$arg $OPTARG"
		Eoptions="$Eoptions -$arg $OPTARG"
		;;
	[BOICehTHni])
		Coptions="$Coptions -$arg $OPTARG"
		;;
	X)
		Eoptions="$Eoptions -$arg $OPTARG"
		;;
        L)	lflag='-L'
		;;
	\?)	echo $usage >&2; exit 1
		;;
	esac
done
shift `expr $OPTIND - 1`

#
# setting file lists
#
while [ $# -gt 0 -a "$1" != "--" ]
do
	case "$1" in
	*.ql)	qlfiles="$qlfiles $1" ;;
	*.qle)	qlefiles="$qlefiles $1" ;;
	*.qi)	qifiles="$qifiles $1" ;;
	*.qg)	qgfiles="$qgfiles $1" ;;
	*.qge)	qgefiles="$qgefiles $1" ;;
	*.qs)	qsfiles="$qsfiles $1" ;;
	*.qo)	qofiles="$qofiles $1" ;;
	*)	echo $usage >&2; exit 1 ;;
	esac
	shift 1
done

if [ "$qlfiles$qlefiles$qifiles$qgfiles$qgefiles$qsfiles$qofiles" = "" ]
then
	echo $usage >&2
	exit 1
fi

openfilename=""
#
# trap hangup and interrupt
#
trap "[ -z '\$openfilename' ] || rm -f \$openfilename" 1 2

#
# first pass: preprocess (.ql -> .qi)
#
verbose "preprocessing ..."

for arg in $qlfiles
do
	verbose "	$arg"

	stem=`expr $arg : '\(.*\).ql'`
	openfilename=$stem.qi
	$preprocess $dflag $Poptions < $stem.ql > $stem.qi || exit 1
	newqifiles="$newqifiles $stem.qi"
done
openfilename=""

$eflag && exit 0

#
# first pass for encoded files: expand (.qle -> .qge)
#
verbose "expanding encoded ..."

for arg in $qlefiles 
do
	verbose "	$arg"

	stem=`expr $arg : '\(.*\).qle'`
	openfilename=$stem.qle
	$expand $Coptions -- $dflag $Goptions $stem.qle || exit 1
	newqgefiles="$newqgefiles $stem.qge"
done
openfilename=""

#
# second pass: expand (.qi -> .qge)
#
verbose "expanding ..."

for arg in $qifiles $newqifiles
do
	verbose "	$arg"

	stem=`expr $arg : '\(.*\).qi'`
	openfilename=$stem.qi
	if [ "$compversion" = "boot" ]
	then
		cp $stem.qi $stem.qg
		newqgfiles="$newqgfiles $stem.qg"
	else
		$expand $Coptions -- $dflag $Goptions $stem.qi || exit 1
		newqgefiles="$newqgefiles $stem.qge"
	fi
done
openfilename=""
[ -z "$newqifiles" ] || rm -f $newqifiles

$gflag && exit 0

#
# third pass: compile (.qge -> .qs)
#
verbose "compiling ..."

for arg in $qgefiles $newqgefiles
do
	verbose "	$arg"

	stem=`expr $arg : '\(.*\).qge'`
	openfilename=$stem.qs
	$compile.$compversion $dflag $Coptions $stem.qge || exit 1
	newqsfiles="$newqsfiles $stem.qs"
done
openfilename=""
[ -z "$newqgefiles" ] || rm -f $newqgefiles
#
# third pass (unencoded): compile (.qg -> .qs)
#
verbose "compiling ..."

for arg in $qgfiles $newqgfiles
do
	verbose "	$arg"

	stem=`expr $arg : '\(.*\).qg'`
	openfilename=$stem.qs
	$compile.$compversion $dflag $Coptions $stem.qg || exit 1
	newqsfiles="$newqsfiles $stem.qs"
done
openfilename=""
[ -z "$newqgfiles" ] || rm -f $newqgfiles

$sflag && exit 0

#
# fourth pass: assemble (.qs -> .qo)
#
verbose "assembling ..."

for arg in $qsfiles $newqsfiles
do
	verbose "	$arg"

	stem=`expr $arg : '\(.*\).qs'`
	openfilename=$stem.qo
	if [ "$execfile" != "a.out" ] && $cflag
	then
		$assemble $dflag $Aoptions -i $stem.qs -o $execfile || exit 1
	else
		$assemble $dflag $Aoptions -i $stem.qs -o $stem.qo || exit 1
	fi
	newqofiles="$newqofiles $stem.qo"
done
openfilename=""
[ -z "$newqsfiles" ] || rm -f $newqsfiles

$cflag && exit 0

#
# fifth pass: make save file and executable shell command file
#
verbose "linking"

# make an absolute version of the save file name for use in the command file

case $execfile in
/*)
	absexecfile=$execfile
	;;
*)
	currdir=`pwd`
	case $currdir in
	/u*)
		abspath=`echo $currdir | sed "s,/u./$HOSTNAME/,/homes/,"`
		;;
	/tmp_mnt/*)
		abspath=`echo $currdir | sed 's,/tmp_mnt/homes/[^/]*/,/homes/,'`
		;;
	*)
		abspath=$currdir
		;;
	esac
	absexecfile=$abspath/$execfile
	;;
esac

savefile=$absexecfile.qx

# generate save file

openfilename=$savefile
$link -o "$savefile" $dflag $Loptions $libqofiles $qofiles $newqofiles || exit 1
openfilename=""
[ -z "$newqofiles" ] || rm -f $newqofiles

# make executable file

echo "exec $execute $Eoptions $lflag -Q '$savefile' \$* $*" >$execfile
chmod a+x $execfile
